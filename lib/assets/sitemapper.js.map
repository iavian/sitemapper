{"version":3,"sources":["../../src/assets/sitemapper.js"],"names":["Sitemapper","options","settings","url","timeout","timeoutTable","Promise","resolve","crawl","then","sites","requestOptions","method","uri","resolveWithFullResponse","gzip","requester","response","statusCode","clearTimeout","error","data","body","initializeTimeout","callback","setTimeout","cancel","parse","urlset","map","site","_site","loc","result","_lastmod","lastmod","concat","sitemapindex","sitemap","promiseArray","all","results","filter","reduce","prev","curr","console","warn","err","fetch","duration"],"mappings":"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","sourcesContent":["/**\n * Sitemap Parser\n *\n * Copyright (c) 2020 Sean Thomas Burke\n * Licensed under the MIT license.\n * @author Sean Burke <@seantomburke>\n */\n\nimport xmlParse from 'xml2js-es6-promise';\nimport request from 'request-promise-native';\n\n/**\n * @typedef {Object} Sitemapper\n */\nexport default class Sitemapper {\n  /**\n   * Construct the Sitemapper class\n   *\n   * @params {Object} options to set\n   * @params {string} [options.url] - the Sitemap url (e.g http://wp.seantburke.com/sitemap.xml)\n   * @params {Timeout} [options.timeout] - @see {timeout}\n   *\n   * @example let sitemap = new Sitemapper({\n   *   url: 'http://wp.seantburke.com/sitemap.xml',\n   *   timeout: 15000\n   *  });\n   */\n  constructor(options) {\n    const settings = options || {};\n    this.url = settings.url;\n    this.timeout = settings.timeout || 15000;\n    this.timeoutTable = {};\n  }\n\n  /**\n   * Gets the sites from a sitemap.xml with a given URL\n   *\n   * @public\n   * @param {string} [url] - the Sitemaps url (e.g http://wp.seantburke.com/sitemap.xml)\n   * @returns {Promise<SitesData>}\n   * @example sitemapper.fetch('example.xml')\n   *  .then((sites) => console.log(sites));\n   */\n  fetch(url = this.url) {\n    return new Promise(resolve => this.crawl(url).then(sites => resolve({ url, sites })));\n  }\n\n  /**\n   * Get the timeout\n   *\n   * @example console.log(sitemapper.timeout);\n   * @returns {Timeout}\n   */\n  static get timeout() {\n    return this.timeout;\n  }\n\n  /**\n   * Set the timeout\n   *\n   * @public\n   * @param {Timeout} duration\n   * @example sitemapper.timeout = 15000; // 15 seconds\n   */\n  static set timeout(duration) {\n    this.timeout = duration;\n  }\n\n  /**\n   *\n   * @param {string} url - url for making requests. Should be a link to a sitemaps.xml\n   * @example sitemapper.url = 'http://wp.seantburke.com/sitemap.xml'\n   */\n  static set url(url) {\n    this.url = url;\n  }\n\n  /**\n   * Get the url to parse\n   * @returns {string}\n   * @example console.log(sitemapper.url)\n   */\n  static get url() {\n    return this.url;\n  }\n\n  /**\n   * Requests the URL and uses xmlParse to parse through and find the data\n   *\n   * @private\n   * @param {string} [url] - the Sitemaps url (e.g http://wp.seantburke.com/sitemap.xml)\n   * @returns {Promise<ParseData>}\n   */\n  parse(url = this.url) {\n    const requestOptions = {\n      method: 'GET',\n      uri: url,\n      resolveWithFullResponse: true,\n      gzip: true,\n    };\n\n    return new Promise((resolve) => {\n      const requester = request(requestOptions)\n        .then((response) => {\n          if (!response || response.statusCode !== 200) {\n            clearTimeout(this.timeoutTable[url]);\n            return resolve({ error: response.error, data: response });\n          }\n          return xmlParse(response.body);\n        })\n        .then(data => resolve({ error: null, data }))\n        .catch(response => resolve({ error: response.error, data: {} }));\n\n      this.initializeTimeout(url, requester, resolve);\n    });\n  }\n\n  /**\n   * Timeouts are necessary for large xml trees. This will cancel the call if the request is taking\n   * too long, but will still allow the promises to resolve.\n   *\n   * @private\n   * @param {string} url - url to use as a hash in the timeoutTable\n   * @param {Promise} requester - the promise that creates the web request to the url\n   * @param {Function} callback - the resolve method is used here to resolve the parent promise\n   */\n  initializeTimeout(url, requester, callback) {\n    // this resolves instead of rejects in order to allow other requests to continue\n    this.timeoutTable[url] = setTimeout(() => {\n      requester.cancel();\n\n      callback({\n        error: `request timed out after ${this.timeout} milliseconds`,\n        data: {},\n      });\n    }, this.timeout);\n  }\n\n  /**\n   * Recursive function that will go through a sitemaps tree and get all the sites\n   *\n   * @private\n   * @recursive\n   * @param {string} url - the Sitemaps url (e.g http://wp.seantburke.com/sitemap.xml)\n   * @returns {Promise<SitesArray> | Promise<ParseData>}\n   */\n  crawl(url) {\n    return new Promise((resolve) => {\n      this.parse(url).then(({ error, data }) => {\n        // The promise resolved, remove the timeout\n        clearTimeout(this.timeoutTable[url]);\n\n        if (error) {\n          // Fail silently\n          return resolve([]);\n        } else if (data && data.urlset && data.urlset.url) {\n          const sites = data.urlset.url.map(site => {\n            let _site = site.loc && site.loc[0]\n            if (!_site) {\n              return false\n            }\n            let result = { url: _site }\n            let _lastmod = site.lastmod && site.lastmod[0]\n            if (_lastmod) {\n              result.lastmod = _lastmod\n            }\n            return result\n          });\n\n          return resolve([].concat(sites));\n        } else if (data && data.sitemapindex) {\n          // Map each child url into a promise to create an array of promises\n          const sitemap = data.sitemapindex.sitemap.map(map => map.loc && map.loc[0]);\n          const promiseArray = sitemap.map(site => this.crawl(site));\n\n          // Make sure all the promises resolve then filter and reduce the array\n          return Promise.all(promiseArray).then(results => {\n            const sites = results.filter(result => !result.error)\n              .reduce((prev, curr) => prev.concat(curr), []);\n\n            return resolve(sites);\n          });\n        }\n        // Fail silently\n        return resolve([]);\n      });\n    });\n  }\n\n\n  /**\n   * /**\n   * Gets the sites from a sitemap.xml with a given URL\n   * @deprecated\n   * @param {string} url - url to query\n   * @param {getSitesCallback} callback - callback for sites and error\n   * @callback\n   */\n  getSites(url = this.url, callback) {\n    console.warn(  // eslint-disable-line no-console\n      'function getSites() is deprecated, please use the function fetch()'\n    );\n\n    let err = {};\n    let sites = [];\n    this.fetch(url).then(response => {\n      sites = response.sites;\n    }).catch(error => {\n      err = error;\n    });\n    return callback(err, sites);\n  }\n}\n\n/**\n * Callback for the getSites method\n *\n * @callback getSitesCallback\n * @param {Object} error - error from callback\n * @param {Array} sites - an Array of sitemaps\n */\n\n/**\n * Timeout in milliseconds\n *\n * @typedef {Number} Timeout\n * the number of milliseconds before all requests timeout. The promises will still resolve so\n * you'll still receive parts of the request, but maybe not all urls\n * default is 15000 which is 15 seconds\n */\n\n/**\n * Resolve handler type for the promise in this.parse()\n *\n * @typedef {Object} ParseData\n *\n * @property {Error} error that either comes from `xmlParse` or `request` or custom error\n * @property {Object} data\n * @property {string} data.url - URL of sitemap\n * @property {Array} data.urlset - Array of returned URLs\n * @property {string} data.urlset.url - single Url\n * @property {Object} data.sitemapindex - index of sitemap\n * @property {string} data.sitemapindex.sitemap - Sitemap\n * @example {\n *   error: \"There was an error!\"\n *   data: {\n *     url: 'linkedin.com',\n *     urlset: [{\n *       url: 'www.linkedin.com/project1'\n *     },[{\n *       url: 'www.linkedin.com/project2'\n *     }]\n *   }\n * }\n */\n\n/**\n * Resolve handler type for the promise in this.parse()\n *\n * @typedef {Object} SitesData\n *\n * @property {string} url - the original url used to query the data\n * @property {SitesArray} sites\n * @example {\n *   url: 'linkedin.com/sitemap.xml',\n *   sites: [\n *     'linkedin.com/project1',\n *     'linkedin.com/project2'\n *   ]\n * }\n */\n\n/**\n * An array of urls\n *\n * @typedef {String[]} SitesArray\n * @example [\n *   'www.google.com',\n *   'www.linkedin.com'\n * ]\n */\n"],"file":"sitemapper.js"}